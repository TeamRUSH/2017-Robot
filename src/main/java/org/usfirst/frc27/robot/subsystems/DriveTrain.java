// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc27.robot.subsystems;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Joystick.AxisType;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc27.robot.Robot;
import org.usfirst.frc27.robot.RobotMap;
import org.usfirst.frc27.robot.commands.DriveTrain.DriveWithJoysticks;
import org.usfirst.frc27.robot.util.NumericUtil;


/**
 *
 */
public class DriveTrain extends PIDSubsystem {

	private final CANTalon leftDriveMaster = RobotMap.driveTrainLeftMotor1;
	private final CANTalon leftDriveSlave = RobotMap.driveTrainLeftMotor2;

	private final CANTalon rightDriveMaster = RobotMap.driveTrainRightMotor1;
	private final CANTalon rightDriveSlave = RobotMap.driveTrainRightMotor2;

    private final RobotDrive robotDrive;  
    
    // sensitivity is used for teleop drive throttling.  A lower sensitivity setting
    // will make the top speed of the motor lower.  Generally we won't want to vary this
    // during competition, but it's nice to have available for practice.
	private double sensitivity;
	
	// sensitivityMultiplier is 0 when we want to ignore the sensitivity value, 1 when we
	// want to use the sensitivity value.
	private int sensitivityMultiplier = 1;
	
	private TalonControlMode activeControlMode;
	
	private AHRS ahrs;
	
	
	PIDController turnController;
	private int turnRequests;
	
	
    public DriveTrain()
    {
    	// super supplies the PID constants (kP, kI, kD)
    	// These initial settings are overridden later in the code.
		// I = .0005
    	super("DriveTrain", .055, .0003, .1);
    	
    	robotDrive = new RobotDrive(leftDriveMaster, rightDriveMaster);
  
    	//Invert the appropriate controllers
//    	robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
//    	robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);

    	//First tell the talon to be the follower, then tell it who to follow.
    	leftDriveSlave.changeControlMode(TalonControlMode.Follower);
    	leftDriveSlave.set(leftDriveMaster.getDeviceID());

    	rightDriveSlave.changeControlMode(TalonControlMode.Follower);
    	rightDriveSlave.set(rightDriveMaster.getDeviceID());
    	
    	leftDriveMaster.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
		leftDriveMaster.reverseOutput(false);
		leftDriveMaster.reverseSensor(true);
		leftDriveMaster.setInverted(true);
		
    	rightDriveMaster.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
    	rightDriveMaster.reverseOutput(true);
		rightDriveMaster.setInverted(true);
		
		
		ahrs = Robot.navx;
		
		turnController = getPIDController();
       	turnController.disable();
       	turnController.setInputRange(-180,  180);
       	turnController.setOutputRange(-.9, .9);
       	turnController.setContinuous(false);
       	turnController.setAbsoluteTolerance(2);
       	
		
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void initDefaultCommand() 
    { 
	    // Each subsystem can only listen to one Command at a time.
    	// setDefaultCommand defines which Command is listened to when the robot
    	// initially goes into teleop mode.
	    setDefaultCommand(new DriveWithJoysticks());
    } 


    public void stop(){
    	turnController.reset();
    	robotDrive.drive(0, 0);
    }
    
    
    public void takeJoystickInputs(Joystick leftJoystick, Joystick rightJoystick)
    {    	
    	SmartDashboard.putNumber("Sensitivity", 1-leftJoystick.getAxis(AxisType.kZ));
    	SmartDashboard.putNumber("Left Drive Speed", leftDriveMaster.getSpeed());
    	SmartDashboard.putNumber("Right Drive Speed", rightDriveMaster.getSpeed());

    	sensitivity = 1-leftJoystick.getAxis(AxisType.kZ);
    	
    	double leftPower = leftJoystick.getAxis(AxisType.kY) * sensitivity * sensitivityMultiplier;
    	double rightPower = rightJoystick.getAxis(AxisType.kY) * sensitivity * sensitivityMultiplier;
    	if(!turnController.isEnabled()){
    		robotDrive.tankDrive(leftPower, rightPower);
    	}
    }
    
    public void takeArcadeInputs(double speed, double rotation){
    	robotDrive.arcadeDrive(speed, rotation);
    }
    
    
    public void turnToHeading(double heading) {
    	turnController.setSetpoint(heading);
    	turnController.enable();
    	SmartDashboard.putNumber("Turn Requests", turnRequests++);
    }
    

    
    public void setControlMode(TalonControlMode newControlMode) {
    	// We will typically be in PercentVbus or MotionProfile mode.
    	if (activeControlMode == newControlMode) {
    		return;
    	}
    	leftDriveMaster.changeControlMode(newControlMode);
    	rightDriveMaster.changeControlMode(newControlMode);
    	SmartDashboard.putString("Active Mode", newControlMode.toString());
    	activeControlMode = newControlMode;
    }


	public void setSensitivity(double value) {
		sensitivity = value;
	}


	public double getSensitivity() {
		return sensitivity;
	}


	public void toggleSensitivityUsage() {
		if (sensitivityMultiplier == 1) {
			sensitivityMultiplier = 0;
			SmartDashboard.putString("Sensitivity Usage", "Off");
		} else {
			sensitivityMultiplier = 1;
			SmartDashboard.putString("Sensitivity Usage", "On");
		}
	}


    //
    // Motion profiling methods
    //
        
    public void setMPValue(int leftSetpoint, int rightSetpoint) {
    	leftDriveMaster.set(leftSetpoint); 
    	rightDriveMaster.set(rightSetpoint);
    }


	public void setMagicMotionPosition(double leftSetPoint, double rightSetPoint) {
		System.out.format("Setpoints: %f, %f\n", leftSetPoint, rightSetPoint);
		System.out.format("Active Modes %s, %s", leftDriveMaster.getControlMode().toString(), rightDriveMaster.getControlMode().toString());

		leftDriveMaster.set(leftSetPoint);
		rightDriveMaster.set(rightSetPoint);
	}

	//
	// PID controller methods.  Because this is a PIDSubsystem, these overrides are
	// necessary.  But they only start getting called after the enable() method has been called.
	//

	@Override
	protected double returnPIDInput() {
		return Robot.navx.getAngle();
	}


	@Override
	protected void usePIDOutput(double output) {
		DriverStation.reportWarning(String.format("PID Output: %s",output), false);
		robotDrive.tankDrive(-output, output);
	}

	public void enableClosedLoopControl() {
		leftDriveMaster.changeControlMode(TalonControlMode.MotionProfile);
		rightDriveMaster.changeControlMode(TalonControlMode.MotionProfile);

		leftDriveMaster.enableBrakeMode(true);
		leftDriveSlave.enableBrakeMode(true);

		rightDriveMaster.enableBrakeMode(true);
		rightDriveSlave.enableBrakeMode(true);


		leftDriveMaster.setF(Robot.state.getLeftDriveTrainF());
		leftDriveMaster.setP(0.006);
		leftDriveMaster.setI(0);
		leftDriveMaster.setD(0);
		leftDriveMaster.enable();

		rightDriveMaster.setF(Robot.state.getRightDriveTrainF());
		rightDriveMaster.setP(0.006);
		rightDriveMaster.setI(0);
		rightDriveMaster.setD(0);
		rightDriveMaster.enable();

	}

	public void enableOperatorControl() {
		leftDriveMaster.changeControlMode(TalonControlMode.PercentVbus);
		rightDriveMaster.changeControlMode(TalonControlMode.PercentVbus);

		leftDriveMaster.enableBrakeMode(false);
		rightDriveMaster.enableBrakeMode(false);
		leftDriveSlave.enableBrakeMode(false);
		rightDriveSlave.enableBrakeMode(false);
		robotDrive.setSafetyEnabled(true);
		Robot.state.setClosedLoopDrive(false);
	}

	public void takeRawValue(double left, double right) {
		robotDrive.tankDrive(left, right);
	}

	public void enableTurnMode() {
		leftDriveMaster.changeControlMode(TalonControlMode.PercentVbus);
		rightDriveMaster.changeControlMode(TalonControlMode.PercentVbus);

		double p = 0.055;
		double i = 0.0003;
		double d = 0.125;

		turnController.setPID(p,i,d);

		leftDriveMaster.enable();
		rightDriveMaster.enable();
	}
	
	public void enableSecondaryClosedLoopMode() {
		leftDriveMaster.changeControlMode(TalonControlMode.Speed);
		rightDriveMaster.changeControlMode(TalonControlMode.Speed);


		leftDriveMaster.setF(.1875);
		leftDriveMaster.setP(.006);
		leftDriveMaster.setI(0);
		leftDriveMaster.setD(0);

		rightDriveMaster.setF(.1875);
		rightDriveMaster.setP(.006);
		rightDriveMaster.setI(0);
		rightDriveMaster.setD(0);

		robotDrive.setSafetyEnabled(false);

		leftDriveMaster.enableBrakeMode(true);
		leftDriveSlave.enableBrakeMode(true);

		rightDriveMaster.enableBrakeMode(true);
		rightDriveSlave.enableBrakeMode(true);

		leftDriveMaster.enable();
		rightDriveMaster.enable();

		Robot.state.setClosedLoopDrive(true);
	}

	public void enableGearMode(){
		robotDrive.setSafetyEnabled(false);

		leftDriveMaster.enableBrakeMode(true);
		leftDriveSlave.enableBrakeMode(true);

		rightDriveMaster.enableBrakeMode(true);
		rightDriveSlave.enableBrakeMode(true);
	}


	public void enableBrakeMode() {
		leftDriveMaster.changeControlMode(TalonControlMode.PercentVbus);
		rightDriveMaster.changeControlMode(TalonControlMode.PercentVbus);

		leftDriveMaster.enableBrakeMode(true);
		leftDriveSlave.enableBrakeMode(true);

		rightDriveMaster.enableBrakeMode(true);
		rightDriveSlave.enableBrakeMode(true);

		leftDriveMaster.enable();
		rightDriveMaster.enable();
	}

	public double[] getLeftRotations() {
		final double wheelDiameter = 4;
		
		double[] array = new double[2];
		array[0] = leftDriveMaster.getPosition() * Math.PI * wheelDiameter;
		array[1] = ((leftDriveMaster.getSpeed() * Math.PI * wheelDiameter) / 12) / 60; // in feet / second
		return array;
	}
	
	public double[] getRightRotations(){
		final double wheelDiameter = 4;

		double[] array = new double[2];
		array[0] = rightDriveMaster.getPosition() * Math.PI * wheelDiameter; // in feet
		array[1] = ((rightDriveMaster.getSpeed() * Math.PI * wheelDiameter) / 12) / 60; // in feet / second
		return array;
	}

	public void zeroPosition() {
		rightDriveMaster.setPosition(0);
		leftDriveMaster.setPosition(0);
	}

	public void setSpeedSetpointWithOffset(double rpm, double offset) {
		double leftRPM = rpm * (1-offset);
		double rightRPM = rpm * (1+offset);

		System.out.println("l: " + leftRPM + " - r:" + rightRPM);

		setSpeedSetpoint(leftRPM, rightRPM);
	}

	public void setSpeedSetpoint(double leftRPM, double rightRPM) {
		leftDriveMaster.setSetpoint(leftRPM);
		leftDriveMaster.enable();

		rightDriveMaster.setSetpoint(rightRPM);
		rightDriveMaster.enable();
	}
}

