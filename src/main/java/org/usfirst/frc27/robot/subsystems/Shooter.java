// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc27.robot.subsystems;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc27.robot.Robot;
import org.usfirst.frc27.robot.RobotMap;
import org.usfirst.frc27.robot.util.NumericUtil;

import java.sql.Driver;


/**
 *
 */
public class Shooter extends Subsystem {

    private final CANTalon shooterLeft = RobotMap.shooterMotor1;
    private final CANTalon shooterRight = RobotMap.shooterMotor2;

    private static final int KNOWN_SHOOTER_SPEED = 3750;
    
    private static final double SHOOTER_P = 0.35;
    private static final double SHOOTER_I = 0d;
    private static final double SHOOTER_D = 8d;
    private static final double SHOOTER_F = 0.0235;

    private boolean spinning = false;
    private long spinTime = 0;
    
    public Shooter(){
    }

	public void initDefaultCommand() {
		shooterLeft.enableBrakeMode(false);
		shooterLeft.changeControlMode(TalonControlMode.Speed);
		shooterLeft.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
		shooterLeft.reverseSensor(false);
		shooterLeft.reverseOutput(true);

		shooterRight.enableBrakeMode(false);
		shooterRight.changeControlMode(TalonControlMode.Speed);
		shooterRight.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
		shooterRight.reverseOutput(false);
		shooterRight.reverseSensor(true);
	}

	public void disable(){
		shooterLeft.disable();
		shooterRight.disable();
		spinning = false;
	}
	public void enable(){
		shooterLeft.enable();
		shooterRight.enable();
		enableSpinning();
	}

	public void spinAtConstantPower(){
		shooterLeft.changeControlMode(TalonControlMode.PercentVbus);
		shooterRight.changeControlMode(TalonControlMode.PercentVbus);
		shooterLeft.set(0.3);
		shooterRight.set(0.3);
		enableSpinning();
	}

    public void spinShooter(){
		final String shooterLeftPString = SmartDashboard.getString("shooter_left_pGain", "0");
		final String shooterLeftIString = SmartDashboard.getString("shooter_left_iGain", "0");
		final String shooterLeftDString = SmartDashboard.getString("shooter_left_dGain", "0");
		final String shooterLeftFString = SmartDashboard.getString("shooter_left_fGain", "0");
		final String shooterLeftSetpointString = SmartDashboard.getString("shooter_left_setPoint", "0");

		final String shooterRightPString = SmartDashboard.getString("shooter_right_pGain", "0");
		final String shooterRightIString = SmartDashboard.getString("shooter_right_iGain", "0");
		final String shooterRightDString = SmartDashboard.getString("shooter_right_dGain", "0");
		final String shooterRightFString = SmartDashboard.getString("shooter_right_fGain", "0");
		final String shooterRightSetpointString = SmartDashboard.getString("shooter_right_setPoint", "0");

		final Double shooterLeftP = NumericUtil.tryToGetDoubleValueOf(shooterLeftPString, "Left Shooter P");
		final Double shooterLeftI = NumericUtil.tryToGetDoubleValueOf(shooterLeftIString, "Left Shooter I");
		final Double shooterLeftD = NumericUtil.tryToGetDoubleValueOf(shooterLeftDString, "Left Shooter D");
		final Double shooterLeftF = NumericUtil.tryToGetDoubleValueOf(shooterLeftFString, "Left Shooter F");

		final Double shooterRightP = NumericUtil.tryToGetDoubleValueOf(shooterRightPString, "Right Shooter P");
		final Double shooterRightI = NumericUtil.tryToGetDoubleValueOf(shooterRightIString, "Right Shooter I");
		final Double shooterRightD = NumericUtil.tryToGetDoubleValueOf(shooterRightDString, "Right Shooter D");
		final Double shooterRightF = NumericUtil.tryToGetDoubleValueOf(shooterRightFString, "Right Shooter F");

		final Integer shooterLeftSetpoint = NumericUtil.tryToGetIntegerValueOf(shooterLeftSetpointString, "Left Shooter Setpoint");
		final Integer shooterRightSetpoint = NumericUtil.tryToGetIntegerValueOf(shooterRightSetpointString, "Right Shooter Setpoint");

		DriverStation.reportWarning(String.format("left p: %s i: %s d: %s f: %s setpoint: %s",shooterLeftP,shooterLeftI,shooterLeftD,shooterLeftF,shooterLeftSetpoint), false);
		DriverStation.reportWarning(String.format("right p: %s i: %s d: %s f: %s setpoint: %s",shooterRightP,shooterRightI,shooterRightD,shooterRightF,shooterRightSetpoint), false);


		shooterLeft.setP(shooterLeftP); //.33
		shooterLeft.setI(shooterLeftI); //.00002
		shooterLeft.setD(shooterLeftD); //0
		shooterLeft.setF(shooterLeftF); //.025

		shooterRight.setP(shooterRightP); //.33
		shooterRight.setI(shooterRightI); //.00002
		shooterRight.setD(shooterRightD); //0
		shooterRight.setF(shooterRightF);

		shooterLeft.setSetpoint(shooterLeftSetpoint); // 3575
		shooterRight.setSetpoint(shooterRightSetpoint); // 3575

		shooterLeft.enable();
		shooterRight.enable();
		enableSpinning();
	}

	public void setTurretSpeedFromAngleAndTargetY(Double angle, double targetY) {

		shooterLeft.setP(SHOOTER_P);
		shooterLeft.setI(SHOOTER_I);
		shooterLeft.setD(SHOOTER_D);
		shooterLeft.setF(SHOOTER_F);

		shooterRight.setP(SHOOTER_P);
		shooterRight.setI(SHOOTER_I);
		shooterRight.setD(SHOOTER_D);
		shooterRight.setF(SHOOTER_F);

		double offsetRPM = Robot.state.getSlaveOffset();
		double leftOffset = 66.5;

    	if(angle > 45){
			DriverStation.reportWarning("OffsetLeft Plus",false);
			leftOffset = offsetRPM;
		}
		if(angle < -45){
			DriverStation.reportWarning("OffsetLeft Minus",false);
			leftOffset = -offsetRPM;
		}

		if(Math.abs(angle) > 65){
			leftOffset = leftOffset * 1.5;
		}

		double distance = Robot.state.getDistanceFromPixels(targetY);
		double setRPM = Robot.state.getRpmFromDistance(distance) + Robot.state.getShooterManualOffset();

		DriverStation.reportWarning(String.format("distance: %s setRPM : %s leftOffset: %s angle: %s",distance,setRPM, leftOffset, angle),false);

		SmartDashboard.putString("Manual RPM Offset",Integer.toString(Robot.state.getShooterManualOffset()));

		shooterLeft.setSetpoint(setRPM + Robot.state.getShooterOffset()); // 3575
		shooterRight.setSetpoint(setRPM + leftOffset + Robot.state.getShooterOffset()); // 3575

		shooterLeft.enable();
		shooterRight.enable();
		enableSpinning();
	}

	public void spinShooterAtSpeedWithAngle(double speed, double angle) {

		double offsetRPM = Robot.state.getSlaveOffset();
		double leftOffset = 0;

		if(angle > 45){
			leftOffset = -offsetRPM;
		}
		if(angle < -45){
			leftOffset = offsetRPM;
		}

		shooterLeft.setP(SHOOTER_P); //.33
		shooterLeft.setI(SHOOTER_I); //.00002
		shooterLeft.setD(SHOOTER_D); //0
		shooterLeft.setF(SHOOTER_F); //.025
		
		shooterRight.setP(SHOOTER_P); //.33
		shooterRight.setI(SHOOTER_I); //.00002
		shooterRight.setD(SHOOTER_D); //0
		shooterRight.setF(SHOOTER_F);

		shooterLeft.setSetpoint(speed + leftOffset); // 3575
		shooterRight.setSetpoint(speed); // 3575

		shooterLeft.enable();
		shooterRight.enable();
		enableSpinning();
	}
	
	public void enableSpinning(){
		if(spinning){
		} else {
			spinning = true;
			spinTime = System.currentTimeMillis();
		}
	}

	public boolean isAtSpeed() {
    	double leftError = shooterLeft.getClosedLoopError() / 8d;
    	double rightError = shooterRight.getClosedLoopError() / 8d;

    	long spinDifference = System.currentTimeMillis() - spinTime;
    	
		if(spinning && (Math.abs(spinDifference) > 100) && (leftError < 100 && rightError < 100)){
			return true;
		}
		return false;
	}
}
