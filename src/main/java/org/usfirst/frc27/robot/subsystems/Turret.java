// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc27.robot.subsystems;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc27.robot.Robot;
import org.usfirst.frc27.robot.RobotMap;
import org.usfirst.frc27.robot.commands.Turret.RotateTurretWithJoystick;

import java.math.BigDecimal;


public class Turret extends Subsystem {

	private final CANTalon turret = RobotMap.turretMotor;


	private static final double JOYSTICK_SENSITIVITY_MULTIPLIER = 1;

	private static final int TICKS_PER_ENCODER_ROTATION = 4096;
	private static final double GEAR_RATIO = 30d / 183d;

	private static final double NUMBER_OF_DEGREES_PER_ENCODER_ROTATION = GEAR_RATIO * 360d;
	private static final double NUMBER_OF_DEGREES_PER_TICK = NUMBER_OF_DEGREES_PER_ENCODER_ROTATION / TICKS_PER_ENCODER_ROTATION;

	private static final double PIXY_NUMBER_OF_PIXELS = 320.0;
	private static final double PIXY_FIELD_OF_VIEW = 75.0;
	private static final double NUMBER_OF_DEGREES_PER_PIXEL = PIXY_FIELD_OF_VIEW / PIXY_NUMBER_OF_PIXELS;
	private static final double NUMBER_OF_PIXELS_PER_TICK = NUMBER_OF_DEGREES_PER_PIXEL / NUMBER_OF_DEGREES_PER_TICK;

	private int positionAtHome = 0;

	public Turret() {
		turret.changeControlMode(TalonControlMode.PercentVbus);
		turret.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Absolute);
		turret.setInverted(false);
		turret.enableBrakeMode(true);
		turret.setP(1);
		turret.setI(0);
		turret.setD(0);
		turret.setAllowableClosedLoopErr(0);
	}

	public void initDefaultCommand() {
		setDefaultCommand(new RotateTurretWithJoystick());
	}

	/**
	 * Enables open-loop control
	 */
	public void enableOperatorMode() {
		// Change control mode to open loop
		turret.changeControlMode(TalonControlMode.PercentVbus);
		// Enable open loop control
		turret.enable();
	}

	/**
	 * Enables closed-loop control
	 */
	public void enablePIDMode() {
		// Change control mode to closed loop
		turret.changeControlMode(TalonControlMode.Position);
		// Enable closed loop control
		turret.enable();
	}

	/**
	 * Uses pixels from Pixycam to determine angle to set to
	 *
	 * @param pixels center of object found by pixycam
	 */
	public void setTurretSetpointFromPixels(double pixels) {
		// Have center of camera be 0
		double normalizedPixels = (PIXY_NUMBER_OF_PIXELS / 2) - pixels;

		// Calculated degrees of requested movement based on pixels
		double degrees = NUMBER_OF_DEGREES_PER_PIXEL * normalizedPixels;

		double currentAngle = getAngle();

		// Add above degrees to current angle to actual degree for setpoint
		double angle = currentAngle + degrees;

		double offSetAngle = Robot.state.isComp() ? getOffsetFromLUTByAngleComp(getAngle()) : getOffsetFromLUTByAnglePractice(getAngle());

		SmartDashboard.putString("Manual Angle Offset",Double.toString(Robot.state.getTurretManualOffset()));

		double adjustedAngle = angle + offSetAngle + Robot.state.getAngleOffset() + Robot.state.getTurretManualOffset();

		// Update setpoint
		setTurretSetpointFromDegree(adjustedAngle);
	}

	private double getOffsetFromLUTByAnglePractice(Double x) {
		double offset = 0;

		if (x < -90) {
			offset = 0;
		}
		if (x >= -90 && x < -85) {
			offset = 0;
		}
		if (x >= -85 && x < -75) {
			offset = 1.025;
		}
		if (x >= -75 && x < -65) {
			offset = 1.625;
		}
		if (x >= -65 && x < -55) {
			offset = 2;
		}
		if (x >= -55 && x < -45) {
			offset = 2.275;
		}
		if (x >= -45 && x < -35) {
			offset = 2.51;
		}
		if (x >= -35 && x < -25) {
			offset = 2.7;
		}
		if (x >= -25 && x < -15) {
			offset = 2.852;
		}
		if (x >= -15 && x < -5) {
			offset = 2.953;
		}
		if (x >= -5 && x < 5) {
			offset = 3;
		}
		if (x >= 5 && x < 15) {
			offset = 2.953;
		}
		if (x >= 15 && x < 25) {
			offset = 2.852;
		}
		if (x >= 25 && x < 35) {
			offset = 2.7;
		}
		if (x >= 35 && x < 45) {
			offset = 2.51;
		}
		if (x >= 45 && x < 55) {
			offset = 2.275;
		}
		if (x >= 55 && x < 65) {
			offset = 2;
		}
		if (x >= 65 && x < 75) {
			offset = 1.625;
		}
		if (x >= 75 && x < 85) {
			offset = 1.025;
		}
		if (x >= 85 && x < 94) {
			offset = 0;
		}
		if (x >= 94) {
			offset = -3.5;
		}
		DriverStation.reportWarning(String.format("x: %s y: %s", x, offset), false);

		return offset;
	}

	private double getOffsetFromLUTByAngleComp(Double x) {
		double offset = 0;

		if (x < -85) {
			offset = -6;
		}
		if (x >= -85 && x < -75) {
			offset = 1.025;
		}
		if (x >= -75 && x < -65) {
			offset = 1.625;
		}
		if (x >= -65 && x < -55) {
			offset = -5;
		}
		if (x >= -55 && x < -50) {
			offset = -5;
		}
		if (x >= -50 && x < -35) {
			offset = -5;
		}
		if (x >= -35 && x < -25) {
			offset = 2.7;
		}
		if (x >= -25 && x < -15) {
			offset = 2.852;
		}
		if (x >= -15 && x < -5) {
			offset = 2.953;
		}
		if (x >= -5 && x < 5) {
			offset = 3;
		}
		if (x >= 5 && x < 15) {
			offset = 2.953;
		}
		if (x >= 15 && x < 25) {
			offset = 2.852;
		}
		if (x >= 25 && x < 35) {
			offset = 2.7;
		}
		if (x >= 35 && x < 45) {
			offset = -4;
		}
		if (x >= 45 && x < 55) {
			offset = -4;
		}
		if (x >= 55 && x < 65) {
			offset = -4;
		}
		if (x >= 65 && x < 75) {
			offset = 1.625;
		}
		if (x >= 75 && x < 85) {
			offset = 1.025;
		}
		if (x >= 85 && x < 94) {
			offset = 0;
		}
		if (x >= 94) {
			offset = 1;
		}
		DriverStation.reportWarning(String.format("x: %s y: %s", x, offset), false);

		return offset;
	}

	private double getOffsetFromAngle(double angle) {

		//y = -6E-12x6 + 2E-19x5 + 4E-08x4 - 3E-15x3 - 0.0004x2 + 2E-11x + 3

		// y = -4E-08x4 - 2E-18x3 - 6E-05x2 + 2E-14x + 2.8877

		double x = angle;
		BigDecimal ten = new BigDecimal(10);


//		double offset = ((-6 * Math.pow(10, -12)) * Math.pow(x, 6))
//				+ ((2 * Math.pow(10, -19)) * Math.pow(x, 5))
//				+ ((4 * Math.pow(10, -8)) * Math.pow(x, 4))
//				+ ((-3 * Math.pow(10, -15)) * Math.pow(x, 3))
//				+ (-0.0004 * Math.pow(x, 2))
//				+ ((2 * Math.pow(10, -11)) * x)
//				+ 3;

//		double fourthPower = (Math.pow(10, -8) * -4 ) * Math.pow(x,4);
//		BigDecimal thirdPower = ten.pow(-18).multiply(new BigDecimal(-2)).multiply(x.pow(3));
//		BigDecimal secondPower = ten.pow(-5).multiply(new BigDecimal(-6)).multiply(x.pow(2));
//		BigDecimal firstPower = ten.pow(-14).multiply(new BigDecimal(-2)).multiply(x);
//		BigDecimal constant = new BigDecimal(2.8877);
//
//		BigDecimal offset = fourthPower.add(thirdPower).add(secondPower).add(firstPower).add(constant);


//		double sixthPower = -0.000000000006 * Math.pow(x,6);
//		double fifthPower = 0.0000000000000000002 * Math.pow(x,5);
//		double fourthPower = 0.00000004 * Math.pow(x,4);
//		double thirdPower = -0.000000000000003 * Math.pow(x,3);
//		double secondPower = 0.0004 * Math.pow(x,2);
//		double firstPower = 0.00000000002 * x;
//		double constant = 3;


//		double offset = sixthPower + fifthPower + fourthPower + thirdPower + secondPower + firstPower + constant;

		// (9025 * -0.0004) + 3

		double offset = (-0.0004 * Math.pow(x, 2)) + 3;


		DriverStation.reportWarning(String.format("x: %s y: %s", x, offset), false);

		return offset;
	}

	/**
	 * Sets angle of turret to the requested angle
	 *
	 * @param angle requested angle
	 */
	public void setTurretSetpointFromDegree(Double angle) {
		// Calculate number of encoder ticks based on angle
		double calculatedTicks = getTicksFromAngle(angle);

		// Calculated number of encoder rotations based on ticks
		double calculatedRotations = calculatedTicks / 4096;

		// Set turret setpoint to the calculated rotations
		turret.setSetpoint(calculatedRotations);

		// Enable new turret setpoint
		turret.enable();
	}

	/**
	 * Redefines home as current value and sets soft limits based on that value
	 */
	public void resetPosLeft() {

		// Get the current encoder position
		positionAtHome = turret.getPulseWidthPosition();

		// Set the reverse soft limit to the current position
		turret.setReverseSoftLimit(turret.getPosition());

		// Calculated the number of ticks from home our forward limit is
		double ticksFromHome = Robot.state.getDegreesOfTurretRotation() / NUMBER_OF_DEGREES_PER_TICK;

		// Calculated the actual number of ticks for our forward limit
		double forwardLimitTicks = positionAtHome + ticksFromHome;

		// Calculate the number of rotations for our forward limit
		double forwardLimitRotations = forwardLimitTicks / 4096;

		// Set forward soft limit based on calculated rotations
		turret.setForwardSoftLimit(forwardLimitRotations);
	}
	
	/**
	 * Redefines home as current value and sets soft limits based on that value
	 */
	public void resetPosRight() {

		// Get the current encoder position
		double positionAtBeachHome = turret.getPulseWidthPosition();

		// Set the reverse soft limit to the current position
		turret.setForwardSoftLimit(turret.getPosition());

		// Calculated the number of ticks from home our forward limit is
		double ticksFromHome = Robot.state.getDegreesOfTurretRotation() / NUMBER_OF_DEGREES_PER_TICK;

		// Calculated the actual number of ticks for our forward limit
		Double reverseLimitTicks = positionAtBeachHome - ticksFromHome;
		
		positionAtHome = reverseLimitTicks.intValue();

		// Calculate the number of rotations for our forward limit
		double reverseLimitRotations = reverseLimitTicks / 4096;

		// Set forward soft limit based on calculated rotations
		turret.setReverseSoftLimit(reverseLimitRotations);
	}

	/**
	 * Disables the turret motor
	 */
	public void disable() {
		turret.set(0);
	}

	/**
	 * Takes joystick input, multiplies it by a sensitivity value, and sets the motor to that value
	 *
	 * @param x joystick value to base motor value on
	 */
	public void takeJoystickValue(double x) {
		// Multiply input value by joystick sensitivity to get actual value to set to.
		turret.set(x * JOYSTICK_SENSITIVITY_MULTIPLIER);
	}

	/**
	 * Sets the motor to the given value
	 *
	 * @param x value to set motor to
	 */
	public void takeRealValue(double x) {
		turret.set(x);
	}

	/**
	 * Gets the current angle of the turret
	 *
	 * @return current calibrated angle of turret
	 */
	public Double getAngle() {
		// Get number of ticks from home.
		int adjustedPosition = turret.getPulseWidthPosition() - positionAtHome;

		// Multiply the number of ticks from home by the number of degrees per tick.
		double adjustedAngle = adjustedPosition * NUMBER_OF_DEGREES_PER_TICK;

		// Add the angle at home to the angle calculated above to get real angle
		return adjustedAngle + Robot.state.getDegreesAtHome();
	}

	/**
	 * Gets encoder ticks to move to based on angle
	 *
	 * @param angle angle to move to
	 * @return encoder ticks to move to
	 */
	public int getTicksFromAngle(Double angle) {
		// Remove degrees at home from angle to make home 0
		Double rawAngle = angle - Robot.state.getDegreesAtHome();

		// Get number of ticks from angle
		Double rawTicks = rawAngle / NUMBER_OF_DEGREES_PER_TICK;

		// Add position at home to get ticks to rotate to from home
		return rawTicks.intValue() + positionAtHome;
	}


	/**
	 * Gets encoder rotations to move to based on angle
	 *
	 * @param angle angle to move to
	 * @return encoder rotations to move to
	 */
	public double getRotationsFromAngle(Double angle) {
		return getTicksFromAngle(angle) / 4096;
	}

	/**
	 * Gets the current encoder position in native encoder ticks
	 *
	 * @return current encoder position in ticks
	 */
	public double getTicks() {
		return turret.getPulseWidthPosition();
	}

	/**
	 * Disables turret soft limits
	 */
	public void disableLimits() {
		turret.enableForwardSoftLimit(false);
		turret.enableReverseSoftLimit(false);
	}

	/**
	 * Enables turret soft limits
	 */
	public void enableLimits() {
		turret.enableForwardSoftLimit(true);
		turret.enableReverseSoftLimit(true);
	}
}
